# 一、事务消息

## 1.1 基本实现

基本生产者例子

```java
package org.apache.rocketmq.example.transaction;
public class TransactionProducer {

    public static void main(String[] args) throws MQClientException, InterruptedException {
        TransactionListener transactionListener = new TransactionListenerImpl();
        TransactionMQProducer producer = new TransactionMQProducer("TransactionProducerGroup");
        ExecutorService executorService = new ThreadPoolExecutor(
            2, 5, 100, TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(2000), r -> {
            Thread thread = new Thread(r);
            thread.setName("client-transaction-msg-check-thread");
            return thread;
        });

        producer.setExecutorService(executorService);
        producer.setTransactionListener(transactionListener);
        producer.setNamesrvAddr("192.168.67.2:9876");
        producer.start();

        String[] tags = new String[]{"TagA", "TagB", "TagC", "TagD", "TagE"};
        for (int i = 0; i < 10; i++) {
            try {
                Message msg = new Message("TransactionTopicTest", tags[i % tags.length],
                    "KEY" + i,
                    ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET));
                SendResult sendResult = producer.sendMessageInTransaction(msg, null);
                System.out.printf("%s%n", sendResult);

                Thread.sleep(10);
            } catch (MQClientException | UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }

        for (int i = 0; i < 100000; i++) {
            Thread.sleep(1000);
        }
        producer.shutdown();
    }
}
```

TransactionMQProducer继承了DefaultMQProducer，只是多了一个TransactionListener和执行的线程池。启动

```java
// TransactionMQProducer
@Override
public void start() throws MQClientException {
  this.defaultMQProducerImpl.initTransactionEnv();
  super.start();
}
```

这里基本逻辑就是DefaultMQProducer的，上面一步主要是检查是否有传入线程池，如果没有传入，则需要创建一个。下面看其发送逻辑

```java
public TransactionSendResult sendMessageInTransaction(final Message msg,
       final LocalTransactionExecuter localTransactionExecuter, final Object arg)
  throws MQClientException {
  // 事务监听器
  TransactionListener transactionListener = getCheckListener();
  if (null == localTransactionExecuter && null == transactionListener) {
    throw new MQClientException("tranExecutor is null", null);
  }
  Validators.checkMessage(msg, this.defaultMQProducer);

  SendResult sendResult = null;
  // 标识这条消息的属性：TRANSACTION_PREPARED
  MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, "true");
  MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());
  try {
    // 消息发送
    sendResult = this.send(msg);
  } catch (Exception e) {
    throw new MQClientException("send message Exception", e);
  }

  LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;
  Throwable localException = null;
  switch (sendResult.getSendStatus()) {
    case SEND_OK: {
      try {
        // 回填事务id
        if (sendResult.getTransactionId() != null) {
          msg.putUserProperty("__transactionId__", sendResult.getTransactionId());
        }
        String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);
        if (null != transactionId && !"".equals(transactionId)) {
          msg.setTransactionId(transactionId);
        }
        // 执行本地事务
        if (null != localTransactionExecuter) {
          localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);
        } else if (transactionListener != null) {
          log.debug("Used new transaction API");
          localTransactionState = transactionListener.executeLocalTransaction(msg, arg);
        }
        if (null == localTransactionState) {
          localTransactionState = LocalTransactionState.UNKNOW;
        }

        if (localTransactionState != LocalTransactionState.COMMIT_MESSAGE) {
          log.info("executeLocalTransactionBranch return {}", localTransactionState);
          log.info(msg.toString());
        }
      } catch (Throwable e) {
        log.info("executeLocalTransactionBranch exception", e);
        log.info(msg.toString());
        localException = e;
      }
    }
      break;
    case FLUSH_DISK_TIMEOUT:
    case FLUSH_SLAVE_TIMEOUT:
    case SLAVE_NOT_AVAILABLE:
      localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;
      break;
    default:
      break;
  }

  try {
    //
    this.endTransaction(sendResult, localTransactionState, localException);
  } catch (Exception e) {
    log.warn("local transaction execute " + localTransactionState + ", but end broker transaction failed", e);
  }

  TransactionSendResult transactionSendResult = new TransactionSendResult();
  transactionSendResult.setSendStatus(sendResult.getSendStatus());
  transactionSendResult.setMessageQueue(sendResult.getMessageQueue());
  transactionSendResult.setMsgId(sendResult.getMsgId());
  transactionSendResult.setQueueOffset(sendResult.getQueueOffset());
  transactionSendResult.setTransactionId(sendResult.getTransactionId());
  transactionSendResult.setLocalTransactionState(localTransactionState);
  return transactionSendResult;
}
```

基本流程就是

* 将相关事务id和消息唯一id存入到消息中
* 发送消息
* 处理本地事务
* 返回事务结果

这里先看发送消息，基本流程和非事务消息差别不大，主要是消息属性标识为了事务消息

```java
// DefualtMQProducerImpl#sendKernelImpl
// 事务消息设置
final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
if (tranMsg != null && Boolean.parseBoolean(tranMsg)) {
  sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;
}
```

再看broker端收到消息的处理逻辑

```java
// SendMessageProcessor#sendMessage
PutMessageResult putMessageResult = null;
Map<String, String> oriProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());
// 这里表明消息是prepared状态
String traFlag = oriProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);
if (traFlag != null && Boolean.parseBoolean(traFlag)) {
  if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) {
    response.setCode(ResponseCode.NO_PERMISSION);
    response.setRemark(
      "the broker[" + this.brokerController.getBrokerConfig().getBrokerIP1()
      + "] sending transaction message is forbidden");
    return response;
  }
  putMessageResult = this.brokerController.getTransactionalMessageService().prepareMessage(msgInner);
} else {
  // 消息存储
  putMessageResult = this.brokerController.getMessageStore().putMessage(msgInner);
}
return handlePutMessageResult(putMessageResult, response, request, msgInner, responseHeader, sendMessageContext, ctx, queueIdInt);
```

这里判断是否是事务消息，然后进行处理

```java
// TransactionalMessageServiceImpl
@Override
public PutMessageResult prepareMessage(MessageExtBrokerInner messageInner) {
  return transactionalMessageBridge.putHalfMessage(messageInner);
}
// TransactionalMessageBridge
public PutMessageResult putHalfMessage(MessageExtBrokerInner messageInner) {
  return store.putMessage(parseHalfMessageInner(messageInner));
}
private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) {
  // 将原topic和原queueId存入到属性中
  MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic());
  MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID,
                              String.valueOf(msgInner.getQueueId()));
  msgInner.setSysFlag(
    MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));
  // 构建新的topic：RMQ_SYS_TRANS_HALF_TOPIC和queueId：0
  msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic());
  msgInner.setQueueId(0);
  msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));
  return msgInner;
}
```

后面再将消息持久化到broker上（这里由于topic和queueId都不是原来的，所以也不能直接被原消费者消费。当然了，肯定是会有一个专门的定时任务[`TransactionalMessageService`]来处理这类消息的，这和定时消息是一个道理），返回结果。然后执行本地事务，

```java
localTransactionState = transactionListener.executeLocalTransaction(msg, arg);
```

并且返回本地事务状态为LocalTransactionState，枚举值如下：

- COMMIT_MESSAGE,
- ROLLBACK_MESSAGE,
- UNKNOW

注意：`TransactionListener#executeLocalTransaction`是在发送者成功发送PREPARED消息后，会执行本地事务方法，然后返回本地事务状态；如果PREPARED消息发送失败，则不会调用`TransactionListener#executeLocalTransaction`，并且本地事务消息，设置为`LocalTransactionState.ROLLBACK_MESSAGE`，表示消息需要被回滚。

```java
// DefaultMQProducerImpl#sendMessageInTransaction
try {
this.endTransaction(sendResult, localTransactionState, localException);
} catch (Exception e) {
log.warn("local transaction execute " + localTransactionState + ", but end broker transaction failed", e);
}

// DefaultMQProducerImpl#endTransaction
EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();
requestHeader.setTransactionId(transactionId);
requestHeader.setCommitLogOffset(id.getOffset());
switch (localTransactionState) {
    case COMMIT_MESSAGE:
         requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);
         break;
    case ROLLBACK_MESSAGE:
         requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);
         break;
     case UNKNOW:
         requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);
         break;
     default:
         break;
}
requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());
requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());
requestHeader.setMsgId(sendResult.getMsgId());

String remark = localException != null ? ("executeLocalTransactionBranch exception: " + localException.toString()) : null;
this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, this.defaultMQProducer.getSendMsgTimeout());
```

这里根据不同情况设置不同的请求命令，只调用一次，不重试

```java
public void endTransactionOneway(
        final String addr,
        final EndTransactionRequestHeader requestHeader,
        final String remark,
        final long timeoutMillis
) throws RemotingException, MQBrokerException, InterruptedException {
  RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.END_TRANSACTION, requestHeader);

  request.setRemark(remark);
  this.remotingClient.invokeOneway(addr, request, timeoutMillis);
}
```

也就是说先发送到broker存储起来，然后根据结果执行相关逻辑。这里发送的命令为END_TRANSACTION。其实相当于这里处理来一半。broker在收到此命令请求后使用EndTransactionProcessor来处理

```java
public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws
  RemotingCommandException {
  final RemotingCommand response = RemotingCommand.createResponseCommand(null);
  final EndTransactionRequestHeader requestHeader =
    (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);
  LOGGER.info("Transaction request:{}", requestHeader);
  // slave不支持此类请求 RequestCode.END_TRANSACTION
  if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) {
    response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);
    LOGGER.warn("Message store is slave mode, so end transaction is forbidden. ");
    return response;
  }
  OperationResult result = new OperationResult();
  // 提交
  if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) {
    result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
      RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
      if (res.getCode() == ResponseCode.SUCCESS) {
        // 恢复原始消息
        MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());
        msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));
        msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());
        msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());
        msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());
        // 重新把消息存入，以便消费端消费
        RemotingCommand sendResult = sendFinalMessage(msgInner);
        if (sendResult.getCode() == ResponseCode.SUCCESS) {
         this.brokerController.getTransactionalMessageService()
           .deletePrepareMessage(result.getPrepareMessage());
        }
        return sendResult;
      }
      return res;
    }
  } else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) {
    // 回滚
    result = this.brokerController.getTransactionalMessageService()
      .rollbackMessage(requestHeader);
    if (result.getResponseCode() == ResponseCode.SUCCESS) {
      RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);
      if (res.getCode() == ResponseCode.SUCCESS) {
        // 直接将事务消息删除
        this.brokerController.getTransactionalMessageService()
          .deletePrepareMessage(result.getPrepareMessage());
      }
      return res;
    }
  }
  response.setCode(result.getResponseCode());
  response.setRemark(result.getResponseRemark());
  return response;
}
```

现在就很清楚了，首先将原始消息变换为事务消息存入，成功后执行本地事务，如果本地事务执行成功，再恢复原始消息供消费者消费。

事务消息存储在消息服务器时主题被替换为`RMQ_SYS_TRANS_HALF_ TOPIC`，执行完本地事务返回本地事务状态为 `UN_KNOW` 时，结束事务时将不做任何处理， 而是通过事务状态定时回查以期得到发送端明确的 事务操作(提交事务或 回滚事务) 。

同时假如 Client 执行本地事务，运行时间过长，或者发送了 `COMMIT` 消息或者 `ROLLBACK` 消息，但是这条消息由于网络原因等没有到达 Server 端，那么可能会导致出于 `PREPARED` 的消息越来越多。因此 Broker 会在后台定期给 Client 发送**检查事务状态**的消息。

RocketMQ 通过 TransactionalMessageCheckService 线程定时去检测 `RMQ_SYS_TRANS_HALF TOPIC` 主题中的消息，回查消息的事务状态 。 TransactionalMessageCheckService 的检测频率默认为一分钟，可通过在 broker.conf文件中设置 `transactionChecklnterval`来改变默认值，单位为毫秒 。

```java
public class TransactionalMessageCheckService extends ServiceThread {
  @Override
  public void run() {
    long checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();
    while (!this.isStopped()) {
      this.waitForRunning(checkInterval);
    }
  }
  @Override
  protected void onWaitEnd() {
    long timeout = brokerController.getBrokerConfig().getTransactionTimeOut();
		// 最多检查多少次：15
    int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();
    // 检查事务状态
    this.brokerController.getTransactionalMessageService().check(timeout, checkMax,     
               this.brokerController.getTransactionalMessageCheckListener());
  }
}
```

这里先插入一点，broker其实是将自己作为一个客户端去订阅消费 `RMQ_SYS_TRANS_OP_HALF_TOPIC` 话题中的消息。那如何知道什么时候消费或者说从哪里开始消费呢？这也就是通过上面的服务循环进行检查来实现的。

下面看一下检查的逻辑TransactionalMessageCheckService#check

```java
public void check(long transactionTimeout, int transactionCheckMax,
                  AbstractTransactionalMessageCheckListener listener) {
  try {
    // RMQ_SYS_TRANS_HALF_TOPIC：prepare消息的主题，事务消息首先进入该主题
    // RMQ_SYS_TRANS_OP_HALF_TOPIC：当消息服务器收到事务消息的提交或回滚
    // 请求后，会将消息存储在该主题下
    String topic = MixAll.RMQ_SYS_TRANS_HALF_TOPIC;
    // 获取所有事务消息
    Set<MessageQueue> msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);
    if (msgQueues == null || msgQueues.size() == 0) {
      log.warn("The queue of topic is empty :" + topic);
      return;
    }
    log.debug("Check topic={}, queues={}", topic, msgQueues);
    for (MessageQueue messageQueue : msgQueues) {
      long startTime = System.currentTimeMillis();
      // 拿到对应opQueue
      MessageQueue opQueue = getOpQueue(messageQueue);
      // 获取prepare消息的起始偏移量，这个偏移量起始是存储config/consumerOffset.json中
      // 基本格式就是"offsetTable":{"RMQ_SYS_TRANS_HALF_TOPIC@CID_RMQ_SYS_TRANS":{0:9}}
      long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);
      // 已处理消息，这里是去获取已处理消息的offset
      long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);
      log.info("Before check, the queue={} msgOffset={} opOffset={}", messageQueue, halfOffset, opOffset);
      if (halfOffset < 0 || opOffset < 0) {
        log.error("MessageQueue: {} illegal offset read: {}, op offset: {},skip this queue", messageQueue,halfOffset, opOffset);
        continue;
      }

      List<Long> doneOpOffset = new ArrayList<>();
      HashMap<Long, Long> removeMap = new HashMap<>();
      // 根据当前进度依次从已处理队列拉取32条消息，方便判断当前处理的消息是否已经处理过
      // 如果处理过则无须再次发送事务状态回查请求
      PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);
      if (null == pullResult) {
        log.error("The queue={} check msgOffset={} with opOffset={} failed, pullResult is null", messageQueue, halfOffset, opOffset);
        continue;
      }
      // single thread
      int getMessageNullCount = 1;
      long newOffset = halfOffset;
      long i = halfOffset;
      while (true) {......}
      if (newOffset != halfOffset) {
        transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);
      }
      long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);
      if (newOpOffset != opOffset) {
        transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);
      }
    }
  } catch (Exception e) {
    e.printStackTrace();
    log.error("Check error", e);
  }
}
```

这里首先会获取所有prepare类型的半消息（topic：RMQ_SYS_TRANS_HALF_TOPIC）队列，然后循环处理。循环处理时首先根据某个半消息队列获取对应的所有的opQueue。

> 这里首次查询的时候opQueue应该是空的，创建一个，然后将其存入到opQueueMap，key：半消息messageQueue，value：opQueue

获取半消息队列halfQueueOffset和opQueueOffset，如果这两个偏移量有其中一个小于0表明非法，不处理，跳过。其实每次消息处理的进度都会保存在`config/consumeOffset.json`中。

根据上面的偏移拉取32条op消息，

* RMQ SYS_TRANS_HALF_TOPIC: prepare消息的主题，事务消息首先进入到该主题。 
* RMQ_SYS_TRANS_OP_HALF_TOPIC : 当消息服务器收到事务消息的提交或因滚请求后， 会将消息存储在该主题下

```java
// TransactionalMessageCheckService#check
PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);

private PullResult fillOpRemoveMap(HashMap<Long, Long> removeMap,
   MessageQueue opQueue, long pullOffsetOfOp, long miniOffset, List<Long> doneOpOffset) {
  // 拉取32条消息
  PullResult pullResult = pullOpMsg(opQueue, pullOffsetOfOp, 32);
  if (null == pullResult) {
    return null;
  }
  List<MessageExt> opMsg = pullResult.getMsgFoundList();
  if (opMsg == null) {
    log.warn("The miss op offset={} in queue={} is empty, pullResult={}", pullOffsetOfOp, opQueue, pullResult);
    return pullResult;
  }
  for (MessageExt opMessageExt : opMsg) {
    // 这里取出来的是half queue offset
    Long queueOffset = getLong(new String(opMessageExt.getBody(), TransactionalMessageUtil.charset));
    log.info("Topic: {} tags: {}, OpOffset: {}, HalfOffset: {}", opMessageExt.getTopic(),
             opMessageExt.getTags(), opMessageExt.getQueueOffset(), queueOffset);
    // 已打标的消息，都是要删除的半消息
    if (TransactionalMessageUtil.REMOVETAG.equals(opMessageExt.getTags())) {
      // 如果当前half offset小于最小的half offset，那么表明此消息已处理完毕，防止重复处理
      // 处理完待删除的op消息
      if (queueOffset < miniOffset) {
        doneOpOffset.add(opMessageExt.getQueueOffset());
      } else {
        // 否则存入removeMap,key:halfQueueOffset,value:opQueueOffset
        // 消息已处理过
        removeMap.put(queueOffset, opMessageExt.getQueueOffset());
      }
    } else {
      log.error("Found a illegal tag in opMessageExt= {} ", opMessageExt);
    }
  }
  return pullResult;
}
```

这里的主要功能就是判断消息是否已经处理过了，避免重复处理。正常情况下本地事务处理完成之后client会通知broker处理状态，然后由broker进行处理。但是如果出现一些异常情况，这个通知没有到达broker，那么这里检查过后broker是会回查client消息处理状态的。**对于最后一段逻辑有点迷惑，处理过的消息都会打上tag，但是为什么会区分为“处理过，待删除”和“处理过”两种状态呢？这样的区分有啥作用？而且如果消费进度比最小的offset都小肯定是已经处理过的，但是为啥反过来也是处理过的？**

检查过后继续处理

```java
while (true) {
  // 事务消息状态回查，每次不超过一分钟
  if (System.currentTimeMillis() - startTime > MAX_PROCESS_TIME_LIMIT) {
    log.info("Queue={} process time reach max={}", messageQueue, MAX_PROCESS_TIME_LIMIT);
    break;
  }
  // 已经处理过，跳过
  if (removeMap.containsKey(i)) {
    log.info("Half offset {} has been committed/rolled back", i);
    removeMap.remove(i);
  } else {
    GetResult getResult = getHalfMsg(messageQueue, i);
    MessageExt msgExt = getResult.getMsg();
    if (msgExt == null) {
      if (getMessageNullCount++ > MAX_RETRY_COUNT_WHEN_HALF_NULL) {
        break;
      }
    }
    // 超过15次丢弃,或者消息过期来（超过来设置的文件保存时间:3天）
    if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) {
      listener.resolveDiscardMsg(msgExt);
      newOffset = i + 1;
      i++;
      continue;
    }
    if (msgExt.getStoreTimestamp() >= startTime) {
      log.debug("Fresh stored. the miss offset={}, check it later, store={}", i,
                new Date(msgExt.getStoreTimestamp()));
      break;
    }
    List<MessageExt> opMsg = pullResult.getMsgFoundList();
    // 判断是否超过了transactionTimeout
    boolean isNeedCheck = (opMsg == null && valueOfCurrentMinusBorn > checkImmunityTime)
      || (opMsg != null && (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime > transactionTimeout))
      || (valueOfCurrentMinusBorn <= -1);

    if (isNeedCheck) {
      // 这里就是将消息重新拷贝一份追加到MappedFile末尾
      if (!putBackHalfMsgQueue(msgExt, i)) {
        continue;
      }
      // 发送检查事务状态的请求
      listener.resolveHalfMsg(msgExt);
    } else {
      // 超时了也就不用处理了
      pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);
      log.info("The miss offset:{} in messageQueue:{} need to get more opMsg, result is:{}", i,messageQueue, pullResult);
      continue;
    }
  }
  newOffset = i + 1;
  i++;
}
```

这里有几个检查点

- 首先对于 `while (true)` 的时间设定了限制，不能超过 `MAX_PROCESS_TIME_LIMIT` 这个值。
- 其次，`needDiscard()` 这个方法检查的就是从消息的 `MessageConst.PROPERTY_TRANSACTION_CHECK_TIMES` 属性中，获取到这个消息已经检查了多少次，如果超过 `transactionCheckMax`，那么就需要丢弃。
- `needSkip()` 函数判断的是这条消息自诞生以来，在 Broker 端放置的时间是否超过了 3 天，如果超过 3 天，这条消息也没有必要检查了，因为 RocketMQ 默认存储消息的最长时间就是 3 天。
- `isNeedCheck` 看的主要就是消息诞生的时间是否超过了 `transactionTimeout`。
- `putBackHalfMsgQueue` 主要就是将当前的消息，最新修改的属性等，重新拷贝一份，然后将**新的消息**追加到 `MappedFile` 的末尾。
- `resolveHalfMsg` 就是在线程池中执行发送检查事务状态的任务：

```java
public void resolveHalfMsg(final MessageExt msgExt) {
    executorService.execute(new Runnable() {
        @Override
        public void run() {
            try {
                sendCheckMessage(msgExt);
            } catch (Exception e) {
                LOGGER.error("Send check message error!", e);
            }
        }
    });
}
```

这里就是broker发送 `CHECK_TRANSACTION_STATE` 报文给 Client，完事之后更新本地处理进度。

而client也会对此命令进行处理

```java
public class ClientRemotingProcessor extends AsyncNettyRequestProcessor implements NettyRequestProcessor {
    @Override
    public RemotingCommand processRequest(ChannelHandlerContext ctx,
        RemotingCommand request) throws RemotingCommandException {
        switch (request.getCode()) {
            case RequestCode.CHECK_TRANSACTION_STATE:
                return this.checkTransactionState(ctx, request);
        }
    }
}
```

其实就是解析出相关事务消息信息，检查本地事务的状态，反馈给broker。整体流程如下

![031](./img/031.png)





# ACK权限控制

RocketMQ 从 4.4.0 版本引入了 ACL 权限控制功能。**可以给话题指定权限，只有拥有权限的消费者才可以进行消费**。其余 ACL 特性请查看[权限控制](https://github.com/apache/rocketmq/blob/develop/docs/cn/acl/user_guide.md)。

基本案例

```java
/*
 * <p/> 基本的同步方式
 */
public class Producer {

    private static final String ACL_ACCESS_KEY = "custNo";
    private static final String ACL_SECRET_KEY = "1234567";
    // 定义一个RPCHook
    static RPCHook getAclRPCHook() {
        return new AclClientRPCHook(new SessionCredentials(ACL_ACCESS_KEY,ACL_SECRET_KEY));
    }
    
    public static void main(String[] args) throws MQClientException, InterruptedException {
        DefaultMQProducer producer = new DefaultMQProducer("ProducerGroup", getAclRPCHook());
        producer.setNamesrvAddr("127.0.0.1:9876");
        producer.start();

        for (int i = 0; i < 10; i++) {
            try {
                Message msg = new Message("TopicTest" /* Topic */,
                    "TagA" /* Tag */,
                    ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) 
                );
                SendResult sendResult = producer.send(msg);
                System.out.printf("%s%n", sendResult);
            } catch (Exception e) {
                e.printStackTrace();
                Thread.sleep(1000);
            }
        }
        producer.shutdown();
    }
}
```

这里就是定义一个RPCHook，然后传入到DefaultMQProducer中，当然消费者接收消息时也需要指定同样的RPCHook

```java
DefaultMQPullConsumer consumer = new DefaultMQPullConsumer("please_rename_unique_group_name_6", getAclRPCHook());
```

先看这种情况下生产者的逻辑

```java
// org.apache.rocketmq.client.impl.MQClientAPIImpl.class
this.remotingClient.registerRPCHook(rpcHook);

// org.apache.rocketmq.remoting.netty.NettyRemotingAbstract.java
protected List<RPCHook> rpcHooks = new ArrayList<RPCHook>();
```

这里会将RPCHook维护到一个列表中，在真正发送消息前后会执行hock

```java
private SendResult sendMessageSync(
  final String addr,
  final String brokerName,
  final Message msg,
  final long timeoutMillis,
  final RemotingCommand request
) throws RemotingException, MQBrokerException, InterruptedException {
  RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);
  assert response != null;
  return this.processSendResponse(brokerName, msg, response);
}

@Override
public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis) {
    doBeforeRpcHooks(addr, request);
    // ...
    doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response);   
}
```

下面看一下具体做了什么，首先看doBeforeRpcHooks

```java
protected void doBeforeRpcHooks(String addr, RemotingCommand request) {
  if (rpcHooks.size() > 0) {
    for (RPCHook rpcHook: rpcHooks) {
      rpcHook.doBeforeRequest(addr, request);
    }
  }
}
```

其实后置操作并没有逻辑，这里直接看前置操作逻辑

```java
public void doBeforeRequest(String remoteAddr, RemotingCommand request) {
  // 这里将request的自定义头部上面的所有字段的name和value都存入到了一个
  // sortedMap中，同时将ACCESS_KEY 和 SECURITY_TOKEN (如果有)也放入了进去
  // 自定义头中存放了用户存入的一些属性，将所有字段拼接为字符串，然后获取字节数组
  // 然后和本身的body字节数组拼接在一起得到最终的byte数组
  byte[] total = AclUtils.combineRequestContent(request,
                                                parseRequestContent(request, sessionCredentials.getAccessKey(), sessionCredentials.getSecurityToken()));
  // 通过上面的字节数组计算签名，默认采用SigningAlgorithm.HmacSHA1 算法获取到签
  // 名后的 byte[] 数组，再通过 Base64.encodeBase64 将其转为字符串，返回最终的签名
  String signature = AclUtils.calSignature(total, sessionCredentials.getSecretKey());
  // 将签名、ACCESS_KEY、SECURITY_TOKEN (如果有) 添加到请求的扩展字段中
  request.addExtField(SIGNATURE, signature);
  request.addExtField(ACCESS_KEY, sessionCredentials.getAccessKey());

  // The SecurityToken value is unneccessary,user can choose this one.
  if (sessionCredentials.getSecurityToken() != null) {
    request.addExtField(SECURITY_TOKEN, sessionCredentials.getSecurityToken());
  }
}

@Override
public void doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) {
}
```

这里其实就是将相关自定义内容存入到请求属性当中。



下面看下broker相关到权限验证。

```java
// BrokerController.java
private void initialAcl() {
  // 关闭状态不处理
  if (!this.brokerConfig.isAclEnable()) {
    log.info("The broker dose not enable acl");
    return;
  }
  // 如果用户开启了 ACL，那么会从 META-INF 路径下去加载所有实现了
  // AccessValidator 接口的实现类
  List<AccessValidator> accessValidators = ServiceProvider.load(ServiceProvider.ACL_VALIDATOR_ID, AccessValidator.class);
  if (accessValidators == null || accessValidators.isEmpty()) {
    log.info("The broker dose not load the AccessValidator");
    return;
  }

  for (AccessValidator accessValidator: accessValidators) {
    final AccessValidator validator = accessValidator;
    // 如果存在校验相关实现类，则会注册到服务端上面
    this.registerServerRPCHook(new RPCHook() {

      @Override
      public void doBeforeRequest(String remoteAddr, RemotingCommand request) {
        //Do not catch the exception
        // 执行相关校验逻辑
        validator.validate(validator.parse(request, remoteAddr));
      }

      @Override
      public void doAfterResponse(String remoteAddr, RemotingCommand request, RemotingCommand response) {
      }
    });
  }
}
```

而 Broker 中的 `META-INF/service/org.apache.rocketmq.acl.AccessValidator` 文件存储的内容如下，即采用 `PlainAccessValidator` 作为默认的权限访问校验器。这里会将相关权限参数解析出来然后进行校验，相关权限如下

```
DENY: 拒绝
ANY: PUB 或者 SUB 权限
PUB: 发送权限。即从 Producer 端发送出来的命令，所具有的权限。
SUB: 订阅权限。即从消费端发送出来的命令，所具有的权限。
```

权限校验有几点要注意：

* 检查是否在全局ip白名单中
* 检查是否在用户ip白名单中
* 检查签名
* 依次检查各资源的权限

> 特殊请求如 `UPDATE_AND_CREATE_TOPIC` 等，只能由 admin 账户进行操作
>
> 对于某个资源，如果有显示配置权限，则采用配置的权限，如果没有则采用默认的权限

那上面进行权限检查的时候比如ip白名单是如何管理的呢？

上述校验规则的 `validate` 方法是放在权限管理器 `PlainPermissionManager` 上面的，在新建该类**实例**的时候，其内部会首先加载 YML 格式的权限配置文件，然后在监听这个文件的变化，做到运行时动态的更新权限。

```java
private static final String DEFAULT_PLAIN_ACL_FILE = "/conf/plain_acl.yml";
private String fileName = System.getProperty("rocketmq.acl.plain.file", DEFAULT_PLAIN_ACL_FILE);

public void load() {
    JSONObject plainAclConfData = AclUtils.getYamlDataObject(fileHome + File.separator + fileName, JSONObject.class);
    // ...
}
```

rocketMQ默认在distribution/conf给出了一个权限配置文件 plain_acl.yml。

```yml
# 这个参数就是全局性的白名单
# 这里定义的ip地址，都是可以访问Topic的
globalWhiteRemoteAddresses:
- 13.21.33.*
- 192.168.0.*
# 这个accounts就是说，你在这里可以定义很多账号
# 每个账号都可以在这里配置对哪些Topic具有一些操作权限
accounts:
# 这个accessKey其实就是用户名的意思，比如我们这里叫做“订单技术团队”
- accessKey: OrderTeam
# 这个secretKey其实就是这个用户名的密码
secretKey: 123456
# 下面这个是当前这个用户名下哪些机器要加入白名单的
whiteRemoteAddress:
# admin指的是这个账号是不是管理员账号
admin: false
# 这个指的是默认情况下这个账号的Topic权限和ConsumerGroup权限
defaultTopicPerm: DENY
defaultGroupPerm: SUB
# 这个就是这个账号具体的堆一些账号的权限
# 下面就是说当前这个账号对两个Topic，都具备PUB|SUB权限，就是发布和订阅的权限
# PUB就是发布消息的权限，SUB就是订阅消息的权限
# DENY就是拒绝你这个账号访问这个Topic
topicPerms:
- CreateOrderInformTopic=PUB|SUB
- PaySuccessInformTopic=PUB|SUB
# 下面就是对ConsumerGroup的权限，也是同理的
groupPerms:
- groupA=DENY
- groupB=PUB|SUB
- groupC=SUB
# 下面就是另外一个账号了，比如是商品技术团队的账号
- accessKey: ProductTeam
secretKey: 12345678
whiteRemoteAddress: 192.168.1.*
# 如果admin设置为true，就是具备一切权限
admin: true
```



对此文件的检查监听是通过FileWatchService完成的

```java
FileWatchService fileWatchService = new FileWatchService(new String[] {watchFilePath}, new FileWatchService.Listener() {
    @Override
    public void onChanged(String path) {
        log.info("The plain acl yml changed, reload the context");
        load();
    }
});
fileWatchService.start();
```

在 `FileWatchService` 内部，其每隔 `WATCH_INTERVAL = 500` 毫秒，扫描一次指定的所有文件列表。如果某个文件的 `MD5` 哈希值有变化，就会调用 `listener.onChanged` 方法来通知这个文件发生了变化。



参考

```http
https://kunzhao.org/docs/rocketmq/rocketmq-message-store-flow/
https://www.cnblogs.com/dennyzhangdd/p/15035116.html
https://juejin.cn/post/6844903862147497998
https://www.cnblogs.com/duanxz/p/5020398.html
https://www.cnblogs.com/zhangyjblogs/p/14163380.html#2mappedfilequeue%E7%B1%BB%E8%AF%B4%E6%98%8E
https://www.baiyp.ren/RocketMQ%E6%B6%88%E8%B4%B9%E6%B6%88%E6%81%AF.html
《RocketMQ技术内幕》
https://blog.csdn.net/qq924862077/article/details/104547599
https://cloud.tencent.com/developer/article/1491188
https://blog.csdn.net/qq924862077/article/details/104547599
```











