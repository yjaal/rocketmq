# 一、基本说明

这里使用的是`4.5.1`版本代码进行分析

工程打开后首先需要将`distribution`模块下面的`conf`目录拷贝一份到根目录，然后`namesrv`启动的时候默认会从环境变量下面去找配置，需要在启动配置处配置环境变量

```
ROCKETMQ_HOME=/Users/YJ/study/java-work/rocketmq
```

然后就可以启动`namesrv`模块了。



对于broker模块，可以通过BrokerStartup来进行启动，当然也需要配置启动环境变量

```
// Programe arguments指定配置文件
-c /Users/YJ/study/java-work/rocketmq/conf/broker.conf
// Envirenment varialbes
ROCKETMQ_HOME=/Users/YJ/study/java-work/rocketmq;NAMESRV_ADDR=127.0.0.1:9876
```

启动后就可以使用之前测试使用的例子进行测试了，只是需要将服务地址修改一下，可以使用quickstart中的例子进行测试。这里先启动consumer，然后再启动producer。可以对源码进行调试。



几个核心的模块

- **namesrv**：命名发现服务，broker 服务的管理与路由
- **broker**：核心组件，接收 `producer`发送的消息和消息的存储与`consumer` 的消息消费
- **client**：客户端实现，`producer`和 `consumer`的实现模块
- **store**：存储层实现，消息持久化、索引服务、高可用 HA 服务实现
- **remoting**：通信层实现，基于 Netty 的底层封装，服务间的交互通讯都依赖此模块
- **filter**：消息过滤服务，相当于在`broker`和`consumer`中间加入了一个 filter 代理
- **common**：模块间通用的功能类、方法、配置文件、常量等
- **tools**：命令管理工具，提供了消息查询、topic 管理等功能
- **example**：官方提供的例子，对典型的功能比如 order message，push consumer，pull consumer 的用法进行了示范



# 二、源码分析

## 2.1 NameServer

![005.png](./img/005.png)

### 2.1.1 启动

```java
public static NamesrvController main0(String[] args) {
  try {
    NamesrvController controller = createNamesrvController(args);
    start(controller);
    // ...
```

在此方法中主要的内容就是NamesrvController的构建和启动。

**构建nameServer**

```java
public NamesrvController(NamesrvConfig namesrvConfig, NettyServerConfig nettyServerConfig) {
  this.namesrvConfig = namesrvConfig;
  this.nettyServerConfig = nettyServerConfig;
  this.kvConfigManager = new KVConfigManager(this);
  this.routeInfoManager = new RouteInfoManager();
  this.brokerHousekeepingService = new BrokerHousekeepingService(this);
  this.configuration = new Configuration(log,this.namesrvConfig, this.nettyServerConfig
  );
  this.configuration.setStorePathFromConfig(this.namesrvConfig, "configStorePath");
}
```

可以看到构建nameServer主要是设置一些配置，主要有自己本身的配置信息和Netty服务的配置信息，同时会将-c指定的配置文件信息设置进来

```java
controller.getConfiguration().registerConfig(properties);
```

**启动nameServer**

```java
public static NamesrvController start(final NamesrvController controller) throws Exception {
  // nameServer初始化
  boolean initResult = controller.initialize();
  if (!initResult) {
    controller.shutdown();
    System.exit(-3);
  }

  // 设置nameServer关闭回调
  Runtime.getRuntime().addShutdownHook(new ShutdownHookThread(log, new Callable<Void>() {
    @Override
    public Void call() throws Exception {
      controller.shutdown();
      return null;
    }
  }));

  // 启动nameServer
  controller.start();
  return controller;
}
```

**初始化**

```java
public boolean initialize() {

  // 加载 KV 配置
  this.kvConfigManager.load();

  // 创建Netty网络对象
  this.remotingServer = new NettyRemotingServer(this.nettyServerConfig, this.brokerHousekeepingService);
  // Netty工作线程池
  this.remotingExecutor =
    Executors.newFixedThreadPool(nettyServerConfig.getServerWorkerThreads(), new ThreadFactoryImpl("RemotingExecutorThread_"));

  this.registerProcessor();

  // 定时任务，对broker进行检测，延迟5s执行，每10s检测一次，移除不活跃对broker
  this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
    @Override
    public void run() {
      NamesrvController.this.routeInfoManager.scanNotActiveBroker();
    }
  }, 5, 10, TimeUnit.SECONDS);

  // nameServer每隔10分钟打印一次KV配置
  this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

    @Override
    public void run() {
      NamesrvController.this.kvConfigManager.printAllPeriodically();
    }
  }, 1, 10, TimeUnit.MINUTES);
	// ....
  return true;
}
```

**启动**

```java
public void start() throws Exception {
  // 启动netty服务器
  this.remotingServer.start();

  if (this.fileWatchService != null) {
    this.fileWatchService.start();
  }
}
```



### 2.1.2 路由

**路由元信息**

```java
public class RouteInfoManager {
    // Topic 消息队列路由信息，消息发送时根据路由表进行负载均衡
    private final HashMap<String/* topic */, List<QueueData>> topicQueueTable;
    // Broker 基础信息， 包含 brokerName、 所属集群名称 、 主备 Broker 地址
    private final HashMap<String/* brokerName */, BrokerData> brokerAddrTable;
    // Broker 集群信息，存储集群中所有 Broker 名称
    private final HashMap<String/* clusterName */, Set<String/* brokerName */>> clusterAddrTable;
    // Broker 状态信息 。 NameServer 每次收到心跳包时会 替换该信息
    private final HashMap<String/* brokerAddr */, BrokerLiveInfo> brokerLiveTable;
    // Broker上的 FilterServer列表，用于类模式消息过滤
    private final HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;
}
public class QueueData implements Comparable<QueueData> {
    // broker名字
    private String brokerName;
    // topic被读取的队列数
    private int readQueueNums;
    // topic消息写入的队列数
    private int writeQueueNums;
    // 读写权限
    private int perm;
    // 同步标记
    private int topicSynFlag;
}
public class BrokerData implements Comparable<BrokerData> {
    // broker所属集群名字
    private String cluster;
    // broker名字
    private String brokerName;
    // brokerId=0表示Master，大于0表示Slave
    private HashMap<Long/* brokerId */, String/* broker address */> brokerAddrs;
}
class BrokerLiveInfo {
    //NameServer上次收到心跳包时间
    private long lastUpdateTimestamp;
    private DataVersion dataVersion;
    private Channel channel;
    //master地址，初次请求是值为空，slave向NameServer注册后返回
    private String haServerAddr;
```



### 2.1.3 服务状态管理

**一种方式是主动探测：**

主动探测是由路由方（比如 NameServer）发起的，每一个被路由方（比如 Broker）需要打开一个端口，然后路由方每隔一段时间（比如 30 秒）探测这些端口是否可用，如果可用就认为服务器正常，否则认为服务不可用，就把服务从列表中删除。这种方式存在的问题就**路由方压力可能过大**，如果被路由方部署的实例较多时，那么每次探测的成本会比较高，探测的时间也比较长，可能会导致路由方可能不能正常工作。

**另一种就是心跳模式：**

心跳模式不在是路由方发起了，改成被路由方每隔一段时间向路由方发送心跳包，路由方记录被路由方的心跳包，包括服务器IP、上报时间等。每一次上报后，更新对应的信息。路由方启动一个定时器，定期检测当前时间和节点，最近续约时间的差值，如果达到一个阈值（比如说90秒），那么认为这个服务节点不可用。

现在大部分需要服务状态管理的中间件，都采用**心跳模式**，没有太多的缺陷，也不会对服务器造成多大的压力。在 RocketMQ 中 NameServer 与 Broker 的通信也是采用 **心跳模式**。

对于broker的心跳机制后面再说，这里先看nameServer机制，之前nameServer初始化的时候注册过broker检测定时任务，每10s执行一次，具体逻辑如下

```java
public void scanNotActiveBroker() {
  Iterator<Entry<String, BrokerLiveInfo>> it = this.brokerLiveTable.entrySet().iterator();
  while (it.hasNext()) {
    Entry<String, BrokerLiveInfo> next = it.next();
    long last = next.getValue().getLastUpdateTimestamp();
    // 120s不活跃，则移除
    if ((last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis()) {
      RemotingUtil.closeChannel(next.getValue().getChannel());
      it.remove();
      log.warn("The broker channel expired, {} {}ms", next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);
      this.onChannelDestroy(next.getKey(), next.getValue().getChannel());
    }
  }
}
```

逻辑比较简单。



## 2.2 Broker启动

![006](./img/006.png)

```java
// BrokerStartup.java, BrokerController.java
public static void main(String[] args) {
  start(createBrokerController(args));
}
public static BrokerController start(BrokerController controller) {
  try {
    // 这里注册所有的broker
    controller.start();
    //......
    return null;
  }
public void start() throws Exception {
    this.registerBrokerAll(true, false, true);
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

      @Override
      public void run() {
        try {
          BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());
        } catch (Throwable e) {
          log.error("registerBrokerAll Exception", e);
        }
      }
    }, 1000 * 10, Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), TimeUnit.MILLISECONDS);
  }

public static BrokerController createBrokerController(String[] args) {
    System.setProperty(RemotingCommand.REMOTING_VERSION_KEY, Integer.toString(MQVersion.CURRENT_VERSION));

    // 设置发送缓存大小
    if (null == System.getProperty(NettySystemConfig.COM_ROCKETMQ_REMOTING_SOCKET_SNDBUF_SIZE)) {
      NettySystemConfig.socketSndbufSize = 131072;
    }
    // 设置接收缓存大小
    if (null == System.getProperty(NettySystemConfig.COM_ROCKETMQ_REMOTING_SOCKET_RCVBUF_SIZE)) {
      NettySystemConfig.socketRcvbufSize = 131072;
    }

    try {
      //PackageConflictDetect.detectFastjson();
      //......

      // 核心配置信息
      final BrokerConfig brokerConfig = new BrokerConfig();
      // 作为服务端需要接收消息
      final NettyServerConfig nettyServerConfig = new NettyServerConfig();
      // 作为客户端需要发送心跳，需要处理事务消息
      final NettyClientConfig nettyClientConfig = new NettyClientConfig();

      // TSL相关
      nettyClientConfig.setUseTLS(Boolean.parseBoolean(System.getProperty(TLS_ENABLE,
                                                                          String.valueOf(TlsSystemConfig.tlsMode == TlsMode.ENFORCING))));
      // 设置监听端口
      nettyServerConfig.setListenPort(10911);
      final MessageStoreConfig messageStoreConfig = new MessageStoreConfig();

      if (BrokerRole.SLAVE == messageStoreConfig.getBrokerRole()) {
        int ratio = messageStoreConfig.getAccessMessageInMemoryMaxRatio() - 10;
        messageStoreConfig.setAccessMessageInMemoryMaxRatio(ratio);
      }

      // 启动一个broker的时候通过-c指定配置文件路径
      if (commandLine.hasOption('c')) {
        String file = commandLine.getOptionValue('c');
        if (file != null) {
          configFile = file;
          InputStream in = new BufferedInputStream(new FileInputStream(file));
          properties = new Properties();
          properties.load(in);

          properties2SystemEnv(properties);
          MixAll.properties2Object(properties, brokerConfig);
          MixAll.properties2Object(properties, nettyServerConfig);
          MixAll.properties2Object(properties, nettyClientConfig);
          MixAll.properties2Object(properties, messageStoreConfig);

          BrokerPathConfigHelper.setBrokerConfigPath(file);
          in.close();
        }
      }

      //......

      // 从配种文件中获取nameServer地址信息
      String namesrvAddr = brokerConfig.getNamesrvAddr();
      if (null != namesrvAddr) {
        try {
          String[] addrArray = namesrvAddr.split(";");
          for (String addr : addrArray) {
            RemotingUtil.string2SocketAddress(addr);
          }
        } catch (Exception e) {
          System.out.printf(
            "The Name Server Address[%s] illegal, please set it as follows, \"127.0.0.1:9876;192.168.0.1:9876\"%n",
            namesrvAddr);
          System.exit(-3);
        }
      }
      // ......
      // 创建controller
      final BrokerController controller = new BrokerController(
        brokerConfig,
        nettyServerConfig,
        nettyClientConfig,
        messageStoreConfig);
      // remember all configs to prevent discard
      controller.getConfiguration().registerConfig(properties);

      // 初始化
      boolean initResult = controller.initialize();
      if (!initResult) {
        controller.shutdown();
        System.exit(-3);
      }

      // 设置回调方法
      Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {
        private volatile boolean hasShutdown = false;
        private AtomicInteger shutdownTimes = new AtomicInteger(0);

        @Override
        public void run() {
          synchronized (this) {
            log.info("Shutdown hook was invoked, {}", this.shutdownTimes.incrementAndGet());
            if (!this.hasShutdown) {
              this.hasShutdown = true;
              long beginTime = System.currentTimeMillis();
              controller.shutdown();
              long consumingTimeTotal = System.currentTimeMillis() - beginTime;
              log.info("Shutdown hook over, consuming total time(ms): {}", consumingTimeTotal);
            }
          }
        }
      }, "ShutdownHook"));
      return controller;
    } catch (Throwable e) {
      e.printStackTrace();
      System.exit(-1);
    }
    return null;
  }
```

这里主要关注初始化操作

```java
public boolean initialize() throws CloneNotSupportedException {
  // 从硬盘加载配置文件
  boolean result = this.topicConfigManager.load();
  result = result && this.consumerOffsetManager.load();
  result = result && this.subscriptionGroupManager.load();
  result = result && this.consumerFilterManager.load();

  if (result) {
    try {
      // 消息存储管理组件
      this.messageStore = new DefaultMessageStore(this.messageStoreConfig,
                                                  this.brokerStatsManager, this.messageArrivingListener, this.brokerConfig);
      if (messageStoreConfig.isEnableDLegerCommitLog()) {
        DLedgerRoleChangeHandler roleChangeHandler =
          new DLedgerRoleChangeHandler(this, (DefaultMessageStore) messageStore);
        ((DLedgerCommitLog)((DefaultMessageStore) messageStore).getCommitLog())
        .getdLedgerServer().getdLedgerLeaderElector()
          .addRoleChangeHandler(roleChangeHandler);
      }
      // broker统计组件
      this.brokerStats = new BrokerStats((DefaultMessageStore) this.messageStore);
      //load plugin
      MessageStorePluginContext context =
        new MessageStorePluginContext(messageStoreConfig, brokerStatsManager, messageArrivingListener, brokerConfig);
      this.messageStore = MessageStoreFactory.build(context, this.messageStore);
      this.messageStore.getDispatcherList()
        .addFirst(new CommitLogDispatcherCalcBitMap(this.brokerConfig, this.consumerFilterManager));
    } catch (IOException e) {
      result = false;
      log.error("Failed to initialize", e);
    }
  }

  result = result && this.messageStore.load();

  if (result) {
    // Netty网络配置加载
    this.remotingServer = new xxxxx(this.nettyServerConfig, this.clientHousekeepingService);
    NettyServerConfig fastConfig = (NettyServerConfig) this.nettyServerConfig.clone();
    fastConfig.setListenPort(nettyServerConfig.getListenPort() - 2);
    this.fastRemotingServer = new NettyRemotingServer(fastConfig, this.clientHousekeepingService);

    // 发送线程池
    this.sendMessageExecutor = new BrokerFixedThreadPoolExecutor(
      this.brokerConfig.getSendMessageThreadPoolNums(),
      this.brokerConfig.getSendMessageThreadPoolNums(),
      1000 * 60,
      TimeUnit.MILLISECONDS,
      this.sendThreadPoolQueue,
      new ThreadFactoryImpl("SendMessageThread_"));
    // 消息接收线程池，处理consume推送请求
    this.pullMessageExecutor = new BrokerFixedThreadPoolExecutor(
      this.brokerConfig.getPullMessageThreadPoolNums(),
      this.brokerConfig.getPullMessageThreadPoolNums(),
      1000 * 60,
      TimeUnit.MILLISECONDS,
      this.pullThreadPoolQueue,
      new ThreadFactoryImpl("PullMessageThread_"));
    // 消息查询线程池
    this.queryMessageExecutor = new BrokerFixedThreadPoolExecutor(
      this.brokerConfig.getQueryMessageThreadPoolNums(),
      this.brokerConfig.getQueryMessageThreadPoolNums(),
      1000 * 60,
      TimeUnit.MILLISECONDS,
      this.queryThreadPoolQueue,
      new ThreadFactoryImpl("QueryMessageThread_"));

    // 命令管理线程池
    this.adminBrokerExecutor =
      Executors.newFixedThreadPool(this.brokerConfig.getAdminBrokerThreadPoolNums(), new ThreadFactoryImpl(
        "AdminBrokerThread_"));

    // 客户端线程池
    this.clientManageExecutor = new ThreadPoolExecutor(
      this.brokerConfig.getClientManageThreadPoolNums(),
      this.brokerConfig.getClientManageThreadPoolNums(),
      1000 * 60,
      TimeUnit.MILLISECONDS,
      this.clientManagerThreadPoolQueue,
      new ThreadFactoryImpl("ClientManageThread_"));

    // 心跳管理线程池
    this.heartbeatExecutor = new BrokerFixedThreadPoolExecutor(
      this.brokerConfig.getHeartbeatThreadPoolNums(),
      this.brokerConfig.getHeartbeatThreadPoolNums(),
      1000 * 60,
      TimeUnit.MILLISECONDS,
      this.heartbeatThreadPoolQueue,
      new ThreadFactoryImpl("HeartbeatThread_", true));

    // 事务结束线程池
    this.endTransactionExecutor = new BrokerFixedThreadPoolExecutor(
      this.brokerConfig.getEndTransactionThreadPoolNums(),
      this.brokerConfig.getEndTransactionThreadPoolNums(),
      1000 * 60,
      TimeUnit.MILLISECONDS,
      this.endTransactionThreadPoolQueue,
      new ThreadFactoryImpl("EndTransactionThread_"));

    // 消费者管理线程池
    this.consumerManageExecutor =
      Executors.newFixedThreadPool(this.brokerConfig.getConsumerManageThreadPoolNums(), new ThreadFactoryImpl(
        "ConsumerManageThread_"));
    // 注册
    this.registerProcessor();

    final long initialDelay = UtilAll.computNextMorningTimeMillis() - System.currentTimeMillis();
    final long period = 1000 * 60 * 60 * 24;
    // broker相关统计任务
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        try {
          BrokerController.this.getBrokerStats().record();
        } catch (Throwable e) {
          log.error("schedule record error.", e);
        }
      }
    }, initialDelay, period, TimeUnit.MILLISECONDS);

    // consume消费offset持久化到硬盘任务
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        try {
          BrokerController.this.consumerOffsetManager.persist();
        } catch (Throwable e) {
          log.error("schedule persist consumerOffset error.", e);
        }
      }
    }, 1000 * 10, this.brokerConfig.getFlushConsumerOffsetInterval(), TimeUnit.MILLISECONDS);

    // 将consume到filter持久化，同时也可以看出过滤策略是用在broker上面的
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        try {
          BrokerController.this.consumerFilterManager.persist();
        } catch (Throwable e) {
          log.error("schedule persist consumer filter error.", e);
        }
      }
    }, 1000 * 10, 1000 * 10, TimeUnit.MILLISECONDS);

    //......

    // 设置nameServer的地址列表，可以通过本地加载，也可以通过远程请求加载
    if (this.brokerConfig.getNamesrvAddr() != null) {
      this.brokerOuterAPI.updateNameServerAddressList(this.brokerConfig.getNamesrvAddr());
      log.info("Set user specified name server address: {}", this.brokerConfig.getNamesrvAddr());
    } else if (this.brokerConfig.isFetchNamesrvAddrByAddressServer()) {
      this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {

        @Override
        public void run() {
          try {
            BrokerController.this.brokerOuterAPI.fetchNameServerAddr();
          } catch (Throwable e) {
            log.error("ScheduledTask fetchNameServerAddr exception", e);
          }
        }
      }, 1000 * 10, 1000 * 60 * 2, TimeUnit.MILLISECONDS);
    }
    //......
    // 这里使用了SPI机制，就是加载通过文件配置的实现（继承共同的一个接口）
    initialTransaction();
    initialAcl();
    initialRpcHooks();
  }
  return result;
}
```

启动方法中主要是向nameServer注册broker信息

## 2.3 Broker注册

RocketMQ路由注册是通过 Broker与 NameServer的心跳功能实现的。 Broker启动时向集群中所有的 NameServer发送心跳包, 每隔 30s 向集群中所有 NameServer 发送心跳包，NameServer收到Broker心跳包时会更新brokerLiveTable缓存中BrokerLivelnfo的 lastUpdateTimestamp，然后 NameServer每隔 10s扫描 brokerLiveTable，如果连续 120s没 有收到心跳包， NameServer将移除该 Broker的路由信息同时关闭 Socket连接。

```java
public void start() throws Exception {
    this.registerBrokerAll(true, false, true);
    this.scheduledExecutorService.scheduleAtFixedRate(new Runnable() {
      @Override
      public void run() {
        try {
          BrokerController.this.registerBrokerAll(true, false, brokerConfig.isForceRegister());
        } catch (Throwable e) {
          log.error("registerBrokerAll Exception", e);
        }
      }
    }, 1000 * 10, Math.max(10000, Math.min(brokerConfig.getRegisterNameServerPeriod(), 60000)), TimeUnit.MILLISECONDS);
}

public synchronized void registerBrokerAll(final boolean checkOrderConfig, boolean oneway, boolean forceRegister) {
  // Topic相关配置信息
  TopicConfigSerializeWrapper topicConfigWrapper = this.getTopicConfigManager().buildTopicConfigSerializeWrapper();

  if (!PermName.isWriteable(this.getBrokerConfig().getBrokerPermission())
      || !PermName.isReadable(this.getBrokerConfig().getBrokerPermission())) {
    ConcurrentHashMap<String, TopicConfig> topicConfigTable = new ConcurrentHashMap<String, TopicConfig>();
    for (TopicConfig topicConfig : topicConfigWrapper.getTopicConfigTable().values()) {
      TopicConfig tmp =
        new TopicConfig(topicConfig.getTopicName(), topicConfig.getReadQueueNums(), topicConfig.getWriteQueueNums(),
                        this.brokerConfig.getBrokerPermission());
      topicConfigTable.put(topicConfig.getTopicName(), tmp);
    }
    topicConfigWrapper.setTopicConfigTable(topicConfigTable);
  }

  // 这里先判断是否需要注册，如果需要则进行注册
  if (forceRegister || needRegister(this.brokerConfig.getBrokerClusterName(),
                                    this.getBrokerAddr(),
                                    this.brokerConfig.getBrokerName(),
                                    this.brokerConfig.getBrokerId(),
                                    this.brokerConfig.getRegisterBrokerTimeoutMills())) {
    doRegisterBrokerAll(checkOrderConfig, oneway, topicConfigWrapper);
  }
}

private boolean needRegister(final String clusterName,
                             final String brokerAddr,
                             final String brokerName,
                             final long brokerId,
                             final int timeoutMills) {

  TopicConfigSerializeWrapper topicConfigWrapper = this.getTopicConfigManager().buildTopicConfigSerializeWrapper();
  // 这里是向nameServer发送请求，确认是否需要注册
  List<Boolean> changeList = brokerOuterAPI.needRegister(clusterName, brokerAddr, brokerName, brokerId, topicConfigWrapper, timeoutMills);
  boolean needRegister = false;
  for (Boolean changed : changeList) {
    if (changed) {
      needRegister = true;
      break;
    }
  }
  return needRegister;
}
// 这里会遍历所有的nameServer注册broker
private void doRegisterBrokerAll(boolean checkOrderConfig, boolean oneway,
                                 TopicConfigSerializeWrapper topicConfigWrapper) {
  List<RegisterBrokerResult> registerBrokerResultList = this.brokerOuterAPI.registerBrokerAll(
    this.brokerConfig.getBrokerClusterName(),
    this.getBrokerAddr(),
    this.brokerConfig.getBrokerName(),
    this.brokerConfig.getBrokerId(),
    this.getHAServerAddr(),
    topicConfigWrapper,
    this.filterServerManager.buildNewFilterServerList(),
    oneway,
    this.brokerConfig.getRegisterBrokerTimeoutMills(),
    this.brokerConfig.isCompressedRegister());
  //......
}
```

- filterServerList。 消息过滤服务器列表 。
- topicConfigWrapper。 主题配置， topicConfigWrapper 内部封装的是 TopicConfig­Manager 中的 topicConfigTable，内部存储的是 Broker启动时默认的一些 `Topic, MixAll.SELF TEST_TOPIC、 MixAll.DEFAULT一TOPIC ( AutoCreateTopic- Enable=true )., MixAll.BENCHMARK TOPIC 、 MixAll.OFFSET MOVED EVENT 、 BrokerConfig#brokerClusterName 、 BrokerConfig#brokerName `。 Broker中 Topic 默认存储在`${Rocket_Home}/store/config/topic.json `中 。



**NameServer处理心跳包**

当boker心跳发送过来时，DefaulRequestProcessor中processRequest方法接收到，然后根据具体的请求命令完成对心跳包的处理。`org.apache.rocketmq.namesrv.processor.DefaultRequestProcessor` 网络处理器解析请求类型， 如果请求类型为 `RequestCode.REGISTER_BROKER`，则请求最终转发到 `RouteInfoManager#registerBroker`。

```java
public RegisterBrokerResult registerBroker(
  final String clusterName,
  final String brokerAddr,
  final String brokerName,
  final long brokerId,
  final String haServerAddr,
  final TopicConfigSerializeWrapper topicConfigWrapper,
  final List<String> filterServerList,
  final Channel channel) {
  RegisterBrokerResult result = new RegisterBrokerResult();
  try {
    try {
      // 加锁，防止并发修改RouteInfoManager路由表
      this.lock.writeLock().lockInterruptibly();

      // 从集群中获取所有broker，判断集群是否存在，不存在则创建一个
      // clusterAddrTable: HashMap<String/* clusterName */, Set<String/* brokerName */>>
      Set<String> brokerNames = this.clusterAddrTable.get(clusterName);
      if (null == brokerNames) {
        brokerNames = new HashSet<String>();
        this.clusterAddrTable.put(clusterName, brokerNames);
      }
      brokerNames.add(brokerName);

      // 维护BrokerData信息，首先从brokerAddrTable根据BrokerName尝试获取Broker信息，如果不存在，则新建
      // BrokerData并放入到 brokerAddrTable, registerFirst设置为true;如果存在 ，
      // 直接替换原先的，registerFirst设置为false，表示非第一次注册
      boolean registerFirst = false;
      BrokerData brokerData = this.brokerAddrTable.get(brokerName);
      if (null == brokerData) {
        registerFirst = true;
        // 集群名称，broker名称，<brokerId, broker地址>
        brokerData = new BrokerData(clusterName, brokerName, new HashMap<Long, String>());
        this.brokerAddrTable.put(brokerName, brokerData);
      }
      Map<Long, String> brokerAddrsMap = brokerData.getBrokerAddrs();
      //Switch slave to master: first remove <1, IP:PORT> in namesrv, then add <0, IP:PORT>
      //The same IP:PORT must only have one record in brokerAddrTable
      Iterator<Entry<Long, String>> it = brokerAddrsMap.entrySet().iterator();
      while (it.hasNext()) {
        Entry<Long, String> item = it.next();
        // 如果信息不一致，则需要移除
        if (null != brokerAddr && brokerAddr.equals(item.getValue()) && brokerId != item.getKey()) {
          it.remove();
        }
      }

      // 将新的信息存入替换老的
      String oldAddr = brokerData.getBrokerAddrs().put(brokerId, brokerAddr);
      // 最初registerFirst为false，如果没有老的地址，则为true，表示首次注册，否则表示非首次注册
      registerFirst = registerFirst || (null == oldAddr);

      // topic配置不为空，且为master broker
      if (null != topicConfigWrapper && MixAll.MASTER_ID == brokerId) {
        // 若topic配置有变化或者是首次注册
        if (this.isBrokerTopicConfigChanged(brokerAddr, topicConfigWrapper.getDataVersion())
            || registerFirst) {
          ConcurrentMap<String, TopicConfig> tcTable =
            topicConfigWrapper.getTopicConfigTable();
          if (tcTable != null) {
            for (Map.Entry<String, TopicConfig> entry : tcTable.entrySet()) {
              // 创建或更新Topic路由元数据，填充topicQueueTable
              this.createAndUpdateQueueData(brokerName, entry.getValue());
            }
          }
        }
      }

      // 更新broker实时存活的信息
      BrokerLiveInfo prevBrokerLiveInfo = this.brokerLiveTable.put(brokerAddr,                    
           new BrokerLiveInfo(System.currentTimeMillis(),                                                               
                              topicConfigWrapper.getDataVersion(), 
                              channel, haServerAddr));
      if (null == prevBrokerLiveInfo) {
        log.info("new broker registered, {} HAServer: {}", brokerAddr, haServerAddr);
      }

      // 注册 Broker 的过滤器Server地址列表，一个 Broker上会关联多个 FilterServer 消息过滤服务器
      if (filterServerList != null) {
        if (filterServerList.isEmpty()) {
          this.filterServerTable.remove(brokerAddr);
        } else {
          this.filterServerTable.put(brokerAddr, filterServerList);
        }
      }

      if (MixAll.MASTER_ID != brokerId) {
        String masterAddr = brokerData.getBrokerAddrs().get(MixAll.MASTER_ID);
        if (masterAddr != null) {
          BrokerLiveInfo brokerLiveInfo = this.brokerLiveTable.get(masterAddr);
          if (brokerLiveInfo != null) {
            result.setHaServerAddr(brokerLiveInfo.getHaServerAddr());
            result.setMasterAddr(masterAddr);
          }
        }
      }
    } finally {
      this.lock.writeLock().unlock();
    }
  } catch (Exception e) {
    log.error("registerBroker Exception", e);
  }

  return result;
}
```

NameServe 与 Broker 保持长连接， Broker 状态存储在 brokerLiveTable 中， NameServer 每收到一个心跳包，将更新 brokerLiveTable 中关于 Broker 的状态信息以及路 由表( topicQueueTable、 brokerAddrTable、 brokerLiveTable、 filterServerTable)。 更新上述 路由表( HashTable)使用了锁粒度较少的读写锁ReadWriteLock，允许多个消息发送者( Producer)并发读， 保证消息发送时的高并发 。 但同一时刻 NameServer 只处理一个 Broker 心跳包，多个心跳 包请求串行执行 。 这也是读写锁经典使用场景，更多关于读写锁的信息，可以参考博文 : http://blog.csdn.net/prestigeding/article/details/53286756



**NameServer路由删除**

Broker 每隔 30s 向 NameServer 发送一个心跳包，心跳包中包含 BrokerId、Broker地址、Broker名称、 Broker所属集群名称、Broker关联的 FilterServer列表。 但是如果 Broker宕机 ， NameServer无法收到心跳包，此时 NameServer如何来剔除这些失效的 Broker 呢? NameServer会每隔 10s 扫描 brokerLiveTable状态表，如果 BrokerLive 的 lastUpdateTimestamp 的时间戳距当前时间超过 120s，则认为 Broker失效，移除该 Broker, 关闭与Broker连接，并同时更新topicQueueTable、 brokerAddrTable、 brokerLiveTable、 filterServerTable。

RocktMQ 有两个触发点来触发路由删除 

1) NameServer定时扫描 brokerLiveTable检测上次心跳包与 当前系统时间的时间差， 如果时间戳大于 120s，则需要移除该 Broker 信息 。
2) Broker在正常被关闭的情况下，会执行 unregisterBroker指令。 由于不管是何种方式触发的路由删除，路由删除的方法都是一样的，就是从 topic­QueueTable、 brokerAddrTable、 brokerLiveTable、 filterServerTable删除与该 Broker相关的 信息，但 RocketMQ 这两种方式维护路由信息时会抽取公共代码。

在nameServer初始化的时候会有broker扫描任务

```java
public void scanNotActiveBroker() {
  Iterator<Entry<String, BrokerLiveInfo>> it = this.brokerLiveTable.entrySet().iterator();
  while (it.hasNext()) {
    Entry<String, BrokerLiveInfo> next = it.next();
    long last = next.getValue().getLastUpdateTimestamp();
    // 120s不活跃，则移除
    if ((last + BROKER_CHANNEL_EXPIRED_TIME) < System.currentTimeMillis()) {
      RemotingUtil.closeChannel(next.getValue().getChannel());
      it.remove();
      log.warn("The broker channel expired, {} {}ms", next.getKey(), BROKER_CHANNEL_EXPIRED_TIME);
      this.onChannelDestroy(next.getKey(), next.getValue().getChannel());
    }
  }
}
```

在onChannelDestroy方法中就是将该需要移除的broker信息从各个管理类中移除掉。同时如果一个Topic中只包含待移除掉broker的队列的话，从路由表总删除该Topic



**路由发现**

生产者在发送消息时，会先从NameServer查询topic对应的路由信息。当然生产者客户端不发送消息的时候NameServer也不会主动推送，因为RocketMQ路由发现是非实时的，当Topic路由出现变化后，客户端需要定时拉取主题最新的路由。根据主题名称拉取路由信息的命令编码为 `GET_ROUTEINTO_BY_TOPIC`。具体生产者的请求流程后面再看，这里先看NameServer的处理。

同样是由DefaulRequestProcessor接收到请求，根据具体的命令`GET_ROUTEINTO_BY_TOPIC`来进行处理

```java
case RequestCode.GET_ROUTEINTO_BY_TOPIC:
	return this.getRouteInfoByTopic(ctx, request);
```

首先来看下路由信息

```java
public class TopicRouteData extends RemotingSerializable {
    // 顺序消息配置内容，来自于kvConfig
    private String orderTopicConf;
    // topic队列元数据
    private List<QueueData> queueDatas;
    // topic分布的broker元数据
    private List<BrokerData> brokerDatas;
    // broker上面过滤服务器列表
    private HashMap<String/* brokerAddr */, List<String>/* Filter Server */> filterServerTable;
```

```java
public RemotingCommand getRouteInfoByTopic(ChannelHandlerContext ctx,
                                               RemotingCommand request) throws RemotingCommandException {
      final RemotingCommand response = RemotingCommand.createResponseCommand(null);
      final GetRouteInfoRequestHeader requestHeader =
        (GetRouteInfoRequestHeader) request.decodeCommandCustomHeader(GetRouteInfoRequestHeader.class);

      // 这里就是从NamerServer中的相关路由表中构造一个TopicRouteData
      TopicRouteData topicRouteData = this.namesrvController.getRouteInfoManager().pickupTopicRouteData(requestHeader.getTopic());

      if (topicRouteData != null) {
        // 如果找到主题对应的路由信息并且该主题为顺序消息，则从 NameServer KVconfig 中获取关于顺序消息相关的配置填充路由信息 。
        // 如果找不到路由信息 CODE 则使用 TOPIC NOT_EXISTS ，表示没有找到对应的路由 。
        if (this.namesrvController.getNamesrvConfig().isOrderMessageEnable()) {
          String orderTopicConf =
            this.namesrvController.getKvConfigManager()
            .getKVConfig(NamesrvUtil.NAMESPACE_ORDER_TOPIC_CONFIG, 	
                         requestHeader.getTopic());
          topicRouteData.setOrderTopicConf(orderTopicConf);
        }

        byte[] content = topicRouteData.encode();
        response.setBody(content);
        response.setCode(ResponseCode.SUCCESS);
        response.setRemark(null);
        return response;
      }

      response.setCode(ResponseCode.TOPIC_NOT_EXIST);
      response.setRemark("No topic route info in name server for the topic: " + requestHeader.getTopic()
                         + FAQUrl.suggestTodo(FAQUrl.APPLY_TOPIC_URL));
      return response;
    }
```

顺序消息有分区有序或全局有序，相关消息顺序性可以参考

```http
https://www.cnblogs.com/hzmark/p/orderly_message.html
```



## 2.4 Producer

这里可以随便找一个简单的例子进行查看，如`org.apache.rocketmq.example.quickstart.Producer`

```java
public class Producer {
    public static void main(String[] args) throws MQClientException, InterruptedException {
        DefaultMQProducer producer = new DefaultMQProducer("ProducerGroup");
        producer.setNamesrvAddr("192.168.67.2:9876;192.168.67.3:9876");
        producer.start();
        for (int i = 0; i < 10; i++) {
            try {
                Message msg = new Message("TopicTest" /* Topic */,
                    "TagA" /* Tag */,
                    ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET)
                );
                SendResult sendResult = producer.send(msg);

                System.out.printf("%s%n", sendResult);
            } catch (Exception e) {
                e.printStackTrace();
                Thread.sleep(1000);
            }
        }
        producer.shutdown();
    }
```

这个简单的例子之前已经说明过，这里首先看下消息的基本结构

```java
// org.apache.rocketmq.common.message.Message
public class Message implements Serializable {
    private static final long serialVersionUID = 8445773977080406428L;

    // 消息主题
    private String topic;
    // 消息Flag，RocketMQ不做处理
    private int flag;
    // 扩展属性
    private Map<String, String> properties;
    // 消息体
    private byte[] body;
    // 事务ID
    private String transactionId;
```

还有一些扩展属性如下，都存放在properties属性中

```java
tag：消息TAG，用于消息过滤。
keys：Message索引键，多个用空格隔开，RocketMQ可以根据这些key快速检索到消息。
waitStoreMsgOK：消息发送时是否等消息存储完成后再返回。
delayTimeLevel：消息延迟级别，用于定时消息或消息重试。
```

比如tag属性的存放

```java
public void setTags(String tags) {
  this.putProperty(MessageConst.PROPERTY_TAGS, tags);
}
```

### 2.4.1 创建

```java
// DefaultMQProducer
public DefaultMQProducer(final String producerGroup) {
  this(null, producerGroup, null);
}
public DefaultMQProducer(final String namespace, final String producerGroup, RPCHook rpcHook) {
  this.namespace = namespace;
  this.producerGroup = producerGroup;
  defaultMQProducerImpl = new DefaultMQProducerImpl(this, rpcHook);
}
// DefaultMQProducerImpl，这里主要是创建了消息发送的线程池
public DefaultMQProducerImpl(final DefaultMQProducer defaultMQProducer, RPCHook rpcHook) {
  this.defaultMQProducer = defaultMQProducer;
  this.rpcHook = rpcHook;

  this.asyncSenderThreadPoolQueue = new LinkedBlockingQueue<Runnable>(50000);
  this.defaultAsyncSenderExecutor = new ThreadPoolExecutor(
    Runtime.getRuntime().availableProcessors(),
    Runtime.getRuntime().availableProcessors(),
    1000 * 60,
    TimeUnit.MILLISECONDS,
    this.asyncSenderThreadPoolQueue,
    new ThreadFactory() {
      private AtomicInteger threadIndex = new AtomicInteger(0);

      @Override
      public Thread newThread(Runnable r) {
        return new Thread(r, "AsyncSenderExecutor_" + this.threadIndex.incrementAndGet());
      }
    });
}
```

其实创建方法还有

```java
public DefaultMQProducer(final String producerGroup, boolean enableMsgTrace) {
  this(null, producerGroup, null, enableMsgTrace, null);
}
```

如果开启了消息轨迹跟踪，那么会创建一个消息轨迹跟踪转发服务，这里在后面再详细看，还有回调函数。

### 2.4.2 启动

对于NameServer来说，Producer和Broker都是客户端，而Producer也是消息生产者。这里分为普通生产者启动和事务消息生产者启动，先看普通消息生产者启动

```java
// DefaultMQProducer
@Override
public void start() throws MQClientException {
  this.setProducerGroup(withNamespace(this.producerGroup));
  // 启动生产者服务
  this.defaultMQProducerImpl.start();
  // 启动消息轨迹转发服务，这里为空
  if (null != traceDispatcher) {
    try {
      traceDispatcher.start(this.getNamesrvAddr(), this.getAccessChannel());
    } catch (MQClientException e) {
      log.warn("trace dispatcher start failed ", e);
    }
  }
}
```

**消息生产者启动**

```java
// DefaultMQProducerImpl
public void start() throws MQClientException {
  this.start(true);
}
public void start(final boolean startFactory) throws MQClientException {
  switch (this.serviceState) {
      // 默认值
    case CREATE_JUST:
      this.serviceState = ServiceState.START_FAILED;
      // 检查生产者组
      this.checkConfig();
      // 改变生产者的instanceName为进程ID
      if (!this.defaultMQProducer.getProducerGroup().equals(MixAll.CLIENT_INNER_PRODUCER_GROUP)) {
        this.defaultMQProducer.changeInstanceNameToPID();
      }
      // 这里得到了一个MQClient实例，producer和consumer都是MQClient实例
      this.mQClientFactory = MQClientManager.getInstance().getAndCreateMQClientInstance(this.defaultMQProducer, rpcHook);
      // 注册生产者，就是将当前生产者加入到这个组中
      boolean registerOK = mQClientFactory.registerProducer(this.defaultMQProducer.getProducerGroup(), this);
      if (!registerOK) {
        this.serviceState = ServiceState.CREATE_JUST;
        throw new MQClientException("The producer group[" + this.defaultMQProducer.getProducerGroup()
                                    + "] has been created before, specify another name please." + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),
                                    null);
      }

      this.topicPublishInfoTable.put(this.defaultMQProducer.getCreateTopicKey(), new TopicPublishInfo());

      if (startFactory) {
        // 启动MQClientInstance
        mQClientFactory.start();
      }

      log.info("the producer [{}] start OK. sendMessageWithVIPChannel={}", this.defaultMQProducer.getProducerGroup(),
               this.defaultMQProducer.isSendMessageWithVIPChannel());
      this.serviceState = ServiceState.RUNNING;
      break;
    case RUNNING:
    case START_FAILED:
    case SHUTDOWN_ALREADY:
      throw new MQClientException("The producer service state not OK, maybe started once, "
                                  + this.serviceState
                                  + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),
                                  null);
    default:
      break;
  }
  this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();
}
```

上面我们先看会获取一个MQClientManager实例，通过这个实例创建一个MQClientInstance工厂mQClientFactory

```java
public MQClientInstance getAndCreateMQClientInstance(final ClientConfig clientConfig, RPCHook rpcHook) {
  // clientId为客户端IP+instance（unitname可选），如果instance为默认值DEFAULT
  // 那么会将instance自动替换为进程id，这样就避免一台物理机上部署两个应用
  String clientId = clientConfig.buildMQClientId();
  // 创建MQClientManagerInstance实例，整个JVM实例中只存在一个这样的实例，维护一个
  // 缓存列表ConcurrentMap<String/* clientId */, MQClientInstance> factoryTable
  MQClientInstance instance = this.factoryTable.get(clientId);
  if (null == instance) {
    instance =
      new MQClientInstance(clientConfig.cloneClientConfig(),
                           this.factoryIndexGenerator.getAndIncrement(), clientId, rpcHook);
    MQClientInstance prev = this.factoryTable.putIfAbsent(clientId, instance);
    if (prev != null) {
      instance = prev;
      log.warn("Returned Previous MQClientInstance for clientId:[{}]", clientId);
    } else {
      log.info("Created new MQClientInstance for clientId:[{}]", clientId);
    }
  }
  return instance;
}
```

这里说的只有一个MQClientInstance说的是一个生产者，如果有多个，那么还是会有多个实例的。然后启动，这个实例后面会用来负责本生产者的管理工作，如发送心跳、网络请求等。

```java
// Start request-response channel
this.mQClientAPIImpl.start();
// Start various schedule tasks
this.startScheduledTask();
// Start pull service
this.pullMessageService.start();
// Start rebalance service负载均衡
this.rebalanceService.start();
// Start push service
this.defaultMQProducer.getDefaultMQProducerImpl().start(false);
```

这里需要注意负载均衡，生产者的负载均衡不是在启动的时候做的，而是在消息发送的时候做的。而消费者的负载均衡是在启动的时候做的，后面再看。

### 2.4.3 消息发送

这里试验只是启动了一个namesrv和broker，实际生产上一般都是多个namesrv和broker。那么broker是如何选择一个namesrv呢？首先namesrv全部都是处于相同状态的，保存的都是相同的信息。在broker启动的时候，会将自己在本地保存的topic信息（默认位于$HOME/store/config/topics.json）中的所有topic加载到内存中，然后将其同步到所有的namesrv中。同时broker也会启动一个定时任务，每隔30s进行一次同步。

而真正在服务的时候，broker只需要选择其中一个namesrv沟通即可

```java
public class NettyRemotingClient extends NettyRemotingAbstract implements RemotingClient {
    private final AtomicInteger namesrvIndex = new AtomicInteger(initValueIndex());
    private static int initValueIndex() {
        Random r = new Random();
        return Math.abs(r.nextInt() % 999) % 999;
    }

    private Channel getAndCreateNameserverChannel() throws InterruptedException {
        // ...
        for (int i = 0; i < addrList.size(); i++) {
            int index = this.namesrvIndex.incrementAndGet();
            index = Math.abs(index);
            index = index % addrList.size();
            String newAddr = addrList.get(index);
            this.namesrvAddrChoosed.set(newAddr);
            Channel channelNew = this.createChannel(newAddr);
            if (channelNew != null)
                return channelNew;
        }
        // ...
    }
}
```

以后，如果 `namesrvAddrChoosed` 选择的服务器如果一直处于连接状态，那么客户端就会一直与这台服务器进行沟通。否则的话，如上源代码所示，就会自动轮寻下一台可用服务器。这里有个问题是，这里建立的连接会保持多久呢？



基本的发送代码

```java
Message msg = new Message("TopicTest" /* Topic */, "TagA" /* Tag */,
                          ("Hello RocketMQ " + i).getBytes(RemotingHelper.DEFAULT_CHARSET) /* Message body */);

/*
 * Call send message to deliver message to one of brokers.
 */
SendResult sendResult = producer.send(msg);
```

首先是构建一个基本的消息体`Message`

```java
// 消息主题
private String topic;
// 消息Flag，RocketMQ不做处理
private int flag;
// 扩展属性
private Map<String, String> properties;
// 消息体
private byte[] body;
// 事务ID
private String transactionId;
```

默认消息发送超时时间为3s

```java
// DefaulMQProducerImpl
public SendResult send(Message msg, long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
  return this.sendDefaultImpl(msg, CommunicationMode.SYNC, null, timeout);
}

private SendResult sendDefaultImpl(
  Message msg,
  final CommunicationMode communicationMode,
  final SendCallback sendCallback,
  final long timeout
) throws MQClientException, RemotingException, MQBrokerException, InterruptedException {
  // 消息长度验证
  // 消息发送之前需要确保生产者处于运行状态，然后验证消息是否符合规范，如主题名称、消息体
  // 不能为空，消息长度不能为0或超过最大长度4M
  this.makeSureStateOK();
  Validators.checkMessage(msg, this.defaultMQProducer);

  final long invokeID = random.nextLong();
  long beginTimestampFirst = System.currentTimeMillis();
  long beginTimestampPrev = beginTimestampFirst;
  long endTimestamp = beginTimestampFirst;
  // 查找路由信息，如果本地没有则就去namesrv查找，如果没找到，则报异常
  TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());
  if (topicPublishInfo != null && topicPublishInfo.ok()) {
    boolean callTimeout = false;
    MessageQueue mq = null;
    Exception exception = null;
    SendResult sendResult = null;
    // 失败重试次数，同步发送只发送一次
    int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;
    int times = 0;
    String[] brokersSent = new String[timesTotal];
    for (; times < timesTotal; times++) {
      String lastBrokerName = null == mq ? null : mq.getBrokerName();
      // 选择消息队列进行发送
      MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);
      if (mqSelected != null) {
        mq = mqSelected;
        brokersSent[times] = mq.getBrokerName();
        try {
          beginTimestampPrev = System.currentTimeMillis();
          if (times > 0) {
            //Reset topic with namespace during resend.
            msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()));
          }
          long costTime = beginTimestampPrev - beginTimestampFirst;
          if (timeout < costTime) {
            callTimeout = true;
            break;
          }

          sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);
          endTimestamp = System.currentTimeMillis();
          this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);
 ...
    }

    if (sendResult != null) {
      return sendResult;
    }

    String info = String.format("Send [%d] times, still failed, cost [%d]ms, Topic: %s, BrokersSent: %s",
                                times,
                                System.currentTimeMillis() - beginTimestampFirst,
                                msg.getTopic(),
                                Arrays.toString(brokersSent));

    info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);

    MQClientException mqClientException = new MQClientException(info, exception);
    if (callTimeout) {
      throw new RemotingTooMuchRequestException("sendDefaultImpl call timeout");
    }
    throw mqClientException;
  }

  List<String> nsList = this.getmQClientFactory().getMQClientAPIImpl().getNameServerAddressList();
  if (null == nsList || nsList.isEmpty()) {
    throw new MQClientException(
      "No name server address, please set it." + FAQUrl.suggestTodo(FAQUrl.NAME_SERVER_ADDR_NOT_EXIST_URL), null).setResponseCode(ClientErrorCode.NO_NAME_SERVER_EXCEPTION);
  }

  throw new MQClientException("No route info of this topic, " + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO),
                              null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);
}
```

**从服务器查找路由信息**

```java
private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) {
  // 根据topic查找相关路由信息，先从缓存中查找
  TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);
  // 第一次为null
  if (null == topicPublishInfo || !topicPublishInfo.ok()) {
    this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());
    // 通过topic向namesrv查找相关路由信息
    this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);
    topicPublishInfo = this.topicPublishInfoTable.get(topic);
  }

  if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) {
    return topicPublishInfo;
  } else {
    this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);
    topicPublishInfo = this.topicPublishInfoTable.get(topic);
    return topicPublishInfo;
  }
}
```

服务器返回的路由信息即broker地址列表（broker ID， broker地址）和消息队列列表（brokerId，可读写队列数，权限）



**选择消息队列进行发送**

```java
public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) {
  // 默认为false：不启用Broker故障延迟机制
  if (this.sendLatencyFaultEnable) {
...
    return tpInfo.selectOneMessageQueue();
  }
  return tpInfo.selectOneMessageQueue(lastBrokerName);
}
```

这里sendLatencyFaultEnable表示是否启用broker故障延迟机制，默认为false，表示不启用。下面先看默认场景

```java
public MessageQueue selectOneMessageQueue(final String lastBrokerName) {
  // lastBrokerName其实就是上一次选择执行发送消息的broker，第一次为null
  if (lastBrokerName == null) {
    return selectOneMessageQueue();
  } else {
    // 后面采用取模轮训方式获取发送的消息队列
    int index = this.sendWhichQueue.getAndIncrement();
    for (int i = 0; i < this.messageQueueList.size(); i++) {
      int pos = Math.abs(index++) % this.messageQueueList.size();
      if (pos < 0)
        pos = 0;
      MessageQueue mq = this.messageQueueList.get(pos);
      if (!mq.getBrokerName().equals(lastBrokerName)) {
        return mq;
      }
    }
    // 如果还是选中了上次发送消息的broker则重新选择
    return selectOneMessageQueue();
  }
}

public MessageQueue selectOneMessageQueue() {
  int index = this.sendWhichQueue.getAndIncrement();
  int pos = Math.abs(index) % this.messageQueueList.size();
  if (pos < 0)
    pos = 0;
  return this.messageQueueList.get(pos);
}
```

从这里可以看到是通过一个取模轮询的方式进行消息发送负载均衡的，下面可以看到从namesrv查询到的路由信息，这里可以看到默认有四个MessageQueue。

![007](./img/007.png)



这里可以看到轮询的时候消息队列是按broker排序的，如果上一次选中的是故障broker的第一个消息队列，那么第二次很可能是该broker的第二个队列，这样导致了不必要的重试。由于故障broker信息不会第一时间同步到namesrv，所以要想避免这种情况，可以采用故障延迟机制

```java
// MQFaultStrategy
// 默认为false：不启用Broker故障延迟机制
if (this.sendLatencyFaultEnable) {
  try {
    // 这里每次自增之后取模，选择其中一个消息队列
    int index = tpInfo.getSendWhichQueue().getAndIncrement();
    for (int i = 0; i < tpInfo.getMessageQueueList().size(); i++) {
      int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();
      if (pos < 0)
        pos = 0;
      MessageQueue mq = tpInfo.getMessageQueueList().get(pos);
      // 判断该broker是否可用
      if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) {
        // 表示上次发送消息的broker
        if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))
          return mq;
      }
    }
    // 从容错队列中选择一个broker
    // 按照可用性排名（是否可用>延迟时间>开始时间）从前半数中RoundRobin选
    final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();
    // 获取该broker中可写消息队列数量
    int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);
    if (writeQueueNums > 0) {
      final MessageQueue mq = tpInfo.selectOneMessageQueue();
      if (notBestBroker != null) {
        mq.setBrokerName(notBestBroker);
        mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);
      }
      return mq;
    } else {
      // 无可写队列则从容错队列中移除
      latencyFaultTolerance.remove(notBestBroker);
    }
  } catch (Exception e) {
    log.error("Error occurred when selecting message queue", e);
  }
  return tpInfo.selectOneMessageQueue();
}
```

基本流程就是：

1. 优先从上一次发送的broker中以RoundRobin形式选择一个可用队列
2. 其次按照可用性排名（是否可用>延迟时间>开始时间）从前半数中RoundRobin选
3. 最次，啥都不管，直接RoundRobin选

这里其实实质就是从上一次发送成功的broker中选择一个队列进行发送。

**故障延迟机制**

```java
// DefaulMQProducerImpl
try {
  beginTimestampPrev = System.currentTimeMillis();
  long costTime = beginTimestampPrev - beginTimestampFirst;
  // 消息发送
  sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);
  endTimestamp = System.currentTimeMillis();
  // 延迟，isolation=false表示使用本次消息发送消耗时间来计算broker规避时长
  this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);
  ...
} catch (RemotingException e) {
  endTimestamp = System.currentTimeMillis();
  // 故障延迟，isolation=true表示使用默认的30s来作为故障延迟规避时长
  this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, true);
  ...
    continue;
}
```

这里分为正常延迟和故障延迟，注意：这里说的是消息正常发送过程中的故障延迟机制，而不是我们在消息发送之前给消息定义的延迟发送时间（或者叫延迟消息）。



**消息发送**

```java
/**
     * @param msg 待发送消息
     * @param mq 消息将发送到该消息队列上
     * @param communicationMode 消息发送模式，SYNC、ASYNC、ONEWAY
     * @param sendCallback 异步消息回调函数
     * @param topicPublishInfo 主题路由信息
     */
private SendResult sendKernelImpl(final Message msg,
                                  final MessageQueue mq,
                                  final CommunicationMode communicationMode,
                                  final SendCallback sendCallback,
                                  final TopicPublishInfo topicPublishInfo,
                                  final long timeout)
```

首先获取broker的网络地址，如果本地没有缓存，那么需要从namesrv获取并更新到本地。

```java
// 获取broker网络地址，如果MQClientInstance的brokerAddrTable未缓存，则需要从
// namesrv获取并更新
String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
if (null == brokerAddr) {
  tryToFindTopicPublishInfo(mq.getTopic());
  brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());
}
```

为消息分配全局唯一ID ，如果消息体默认超过 4K(compressMsgBodyOverHowmuch), 会对消息体采用zip压缩，并设置消息的系统标记为` MessageSysFlag.COMPRESSED_FLAG`。 如果是事务 Prepared消息，则设置消息的系统标记为 `MessageSysFlag.TRANSACTION_ PREPARED TYPE`。

然后检查消息是否设置了钩子函数，可以注册多个钩子函数

```java
// 如果有发送消息钩子，可以通过DefaultMQProducerImpl#registerSendMessageHook
// 注册多个钩子，其逻辑就是定义发送消息前和发送后执行的逻辑
if (this.hasSendMessageHook()) {
  context = new SendMessageContext();
  context.setProducer(this);
  context.setProducerGroup(this.defaultMQProducer.getProducerGroup());
  context.setCommunicationMode(communicationMode);
  context.setBornHost(this.defaultMQProducer.getClientIP());
  context.setBrokerAddr(brokerAddr);
  context.setMessage(msg);
  context.setMq(mq);
  context.setNamespace(this.defaultMQProducer.getNamespace());
  String isTrans = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);
  if (isTrans != null && isTrans.equals("true")) {
    context.setMsgType(MessageType.Trans_Msg_Half);
  }

  if (msg.getProperty("__STARTDELIVERTIME") != null || msg.getProperty(MessageConst.PROPERTY_DELAY_TIME_LEVEL) != null) {
    context.setMsgType(MessageType.Delay_Msg);
  }
  // 执行钩子函数在消息发送前的逻辑
  this.executeSendMessageHookBefore(context);
}
```

钩子函数起始就是定时在消息发送之前和消息发送之后执行的逻辑

**构建消息包**

主要包含如下重要信息:生产者组、主题名称、默认创建主题Key、该主题在单个Broker 默认队列数、队列ID (队列序号) 、消息系统标记 ( MessageSysFlag)、 消息发送时间、消息标记(RocketMQ对消息中的flag不做任何处理，供应用程序使用)、 消息扩展属性、消息重试次数、是否是批量消息等。

**消息发送**

消费发送分为同步、异步、单向方式。异步发送消息需要提供回调函数，而单向模式其实和异步方式类似，只是不需要提供回调函数，也就是发送方不关心消息发送结果。

异步方 式相比同步方式，消息发送端的发送性能会显著提高，但为了保护消息服务器的负载压力， RocketMQ 对消息发送的异步消息进行了井发控制，通过参数 clientAsyncSemaphoreValue 来控制，默认为 65535。 异步消息发送虽然也可以通过 DefaultMQProducer#retryTimes­ WhenSendAsyncFailed 属性来控 制消息重试次数，但是重试的调用人口是在收到服务端响应包时进行的，如果出现网络异常、网络超时等将不会重试。

**broker接受消息**

注意：所有的基本网络请求第一步都是由Netty处理的，rocketMQ在`remoting`模块中封装了Netty网络服务请求。而broker真正对生产者发送过来的消息接受处理是在`SendMessageProcessor#processRequest`中。具体处理时首先对消息进行检查

```java
// AbstractSendMessageProcessor.java
protected RemotingCommand msgCheck(final ChannelHandlerContext ctx,
                                   final SendMessageRequestHeader requestHeader, final RemotingCommand response) {
  // 检查broker是否有写权限
  if (!PermName.isWriteable(this.brokerController.getBrokerConfig().getBrokerPermission())
      && this.brokerController.getTopicConfigManager().isOrderTopic(requestHeader.getTopic())) {
    response.setCode(ResponseCode.NO_PERMISSION);
    response.setRemark("the broker[" + this.brokerController.getBrokerConfig().getBrokerIP1()
                       + "] sending message is forbidden");
    return response;
  }
  // 检查该topic是否可以进行消息发送。因为默认主题不能发送消息，仅供路由查找
  if (!this.brokerController.getTopicConfigManager().isTopicCanSendMessage(requestHeader.getTopic())) {
    String errorMsg = "the topic[" + requestHeader.getTopic() + "] is conflict with system reserved words.";
    log.warn(errorMsg);
    response.setCode(ResponseCode.SYSTEM_ERROR);
    response.setRemark(errorMsg);
    return response;
  }

  TopicConfig topicConfig =
    this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());
  ...

    // 如果话题信息在 Name 服务器不存在的话，那么会使用默认话题信息进行消息的发送
    // 生产者和broker建立联系之后在发送消息时，broker可能没有缓存次topic
    // 此时需要检查topic对存在性，如果不存在则需要缓存到本地，并同步给所有的namesrv
    if (null == topicConfig) {
      if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {
        topicConfig =
          this.brokerController.getTopicConfigManager().createTopicInSendMessageBackMethod(
          requestHeader.getTopic(), 1, PermName.PERM_WRITE | PermName.PERM_READ,
          topicSysFlag);
      }
    }
    ...
  }
```

检查完毕后进行消息重试次数校验，如果超限，则消息将进入到OLD延迟队列；然后进行消息存储。放在后面进行说明。



## 2.5 消息存储







## 2.6 Consumer





## 2.7 延迟消费





